---
title: 什么是Docker？
date: 2022-07-01 12:40:54
tags:
- 容器
categories:
- 软件
- 开发
---
作者：[程序员小灰](https://zhuanlan.zhihu.com/p/187505981)
<!--more-->
## 容器技术的起源

假设你们公司正在秘密研发下一个 “今日头条”APP，我们姑且称为明日头条，程序员自己从头到尾搭建了一套环境开始写代码，写完代码后程序员要把代码交给测试同学测试，这时测试同学开始从头到尾搭建这套环境，测试过程中出现问题程序员也不用担心，大可以一脸无辜的撒娇，“明明在人家的环境上可以运行的”。
测试同学测完后终于可以上线了，这时运维同学又要重新从头到尾搭建这套环境，费了九牛二虎之力搭建好环境开始上线，糟糕，上线系统就崩溃了，这时心理素质好的程序员又可以施展演技了，“明明在人家的环境上可以运行的”。
从整个过程可以看到，不但我们重复搭建了三套环境还要迫使程序员转行演员浪费表演才华，典型的浪费时间和效率，聪明的程序员是永远不会满足现状的，因此又到了程序员改变世界的时候了，容器技术应运而生。

有的同学可能会说：“等等，先别改变世界，我们有虚拟机啊，VMware 好用的飞起，先搭好一套虚拟机环境然后给测试和运维 clone 出来不就可以了吗?”
在没有容器技术之前，这确实是一个好办法，只不过这个办法还没有那么好。
先科普一下，现在云计算其底层的基石就是虚拟机技术，云计算厂商买回来一堆硬件搭建好数据中心后使用虚拟机技术就可以将硬件资源进行切分了，比如可以切分出 100 台虚拟机，这样就可以卖给很多用户了。
你可能会想这个办法为什么不好呢?

## 容器技术 vs 虚拟机

我们知道和一个单纯的应用程序相比，操作系统是一个很重而且很笨的程序，简称笨重，有多笨重呢?
我们知道操作系统运行起来是需要占用很多资源的，大家对此肯定深有体会，刚装好的系统还什么都没有部署，单纯的操作系统其磁盘占用至少几十G起步，内存要几个G起步。

假设我有一台机器，16G 内存，需要部署三个应用，那么使用虚拟机技术可以这样划分：
在这台机器上开启三个虚拟机，每个虚拟机上部署一个应用，其中 VM1 占用 2G 内存，VM2 占用 1G 内存，VM3 占用了 4G 内存。
我们可以看到虚拟本身就占据了总共 7G 内存，因此我们没有办法划分出更多虚拟机从而部署更多的应用程序，可是我们部署的是应用程序，要用的也是应用程序而不是操作系统。

如果有一种技术可以让我们避免把内存浪费在 “无用” 的操作系统上岂不是太香? 这是问题一，主要原因在于操作系统太重了。
还有另一个问题，那就是启动时间问题，我们知道操作系统重启是非常慢的，因为操作系统要从头到尾把该检测的都检测了该加载的都加载上，这个过程非常缓慢，动辄数分钟，因此操作系统还是太笨了。

那么有没有一种技术可以让我们获得虚拟机的好处又能克服这些缺点从而一举实现鱼和熊掌的兼得呢?
答案是肯定的，这就是容器技术。
容器一词的英文是 [container](#容器（Container）)，其实 container 还有集装箱的意思，集装箱绝对是商业史上了不起的一项发明，大大降低了海洋贸易运输成本。让我们来看看集装箱的好处：
1. 集装箱之间相互隔离
2. 长期反复使用
3. 快速装载和卸载
4. 规格标准，在港口和船上都可以摆放

回到软件中的容器，其实容器和集装箱在概念上是很相似的。
现代软件开发的一大目的就是隔离，应用程序在运行时相互独立互不干扰，这种隔离实现起来是很不容易的，其中一种解决方案就是上面提到的虚拟机技术，通过将应用程序部署在不同的虚拟机中从而实现隔离。
但是虚拟机技术有上述提到的各种缺点，那么容器技术又怎么样呢?

与虚拟机通过操作系统实现隔离不同，容器技术只隔离应用程序的运行时环境，但容器之间可以共享同一个操作系统，这里的运行时环境指的是程序运行依赖的各种库以及配置。
容器更加的轻量级且占用的资源更少，与操作系统动辄几 G 的内存占用相比，容器技术只需数 M 空间，因此我们可以在同样规格的硬件上大量部署容器，这是虚拟机所不能比拟的，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动，容器技术为打包服务栈提供了一种更加高效的方式，So cool。

## [docker 中的重要概念](https://blog.csdn.net/xiaoQL520/article/details/121051589)

### 容器（Container）

容器可以被创建、启动、停止、删除、暂停、重启等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间（namespace），具有隔离性。
因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间等。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。
这种特性使得容器封装的应用比直接在宿主运行更加安全，从此再也不用担心本地多个应用需要不同版本的依赖导致的冲突问题了。

### 镜像（Image）

实际上你可以简单的把 image 理解为可执行程序，container 就是运行起来的进程。
Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、依赖库、资源、配置文件、运行时的配置参数（如：匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

### 仓库（Repository）

docker 中 image 的概念就类似于 “可执行程序”，我们可以从哪里下载到别人写好的应用程序呢? 很简单，那就是 APP Store，即应用商店。
与之类似，既然 image 也是一种 “可执行程序”，那么有没有 "Docker Image Store" 呢? 答案是肯定的，这就是 Docker Hub，docker 官方的 “应用商店”，你可以在这里下载到别人编写好的 image，这样你就不用自己编写 dockerfile 了。
`docker registry` 可以用来存放各种 image，公共的可以供任何人下载 image 的仓库就是 docker Hub。那么该怎么从 Docker Hub 中下载 image 呢，就是下面的 [docker pull](#4-docker-pull) 命令了。

## docker 的工作流程

实际上 docker 使用了常见的 `CS 架构`，也就是 `client-server` 模式，`docker client` 负责处理用户输入的各种命令，比如 docker build、docker run，真正工作的其实是 server，也就是 `docker demon`，值得注意的是，docker client 和 docker demon 可以运行在同一台机器上。
### 1. dockerfile
写程序需要源代码，那么 “写”image 就需要 dockerfile，dockerfile 就是 `image 的源代码`，docker 就是 "编译器"。
因此我们只需要在 dockerfile 中指定**需要哪些程序、依赖什么样的配置**，之后把 dockerfile 交给 “编译器”docker 进行 “编译”，也就是 [docker build](#2-docker-build) 命令，生成的可执行程序就是 image，之后就可以运行这个 image 了，这就是 [docker run](#3-docker-run) 命令，image 运行起来后就是 docker container。
docker build 和 docker run 是两个最核心的命令，会用这两个命令基本上 docker 就可以用起来了，剩下的就是一些补充。
### 2. docker build
当我们写完 dockerfile 交给 docker“编译” 时使用这个命令，那么 client 在接收到请求后转发给 docker daemon，接着 docker daemon 根据 dockerfile 创建出 “可执行程序”[image](#镜像（Image）)。
### 3. docker run
有了 “可执行程序”image 后就可以运行程序了，接下来使用命令 docker run，docker daemon 接收到该命令后找到具体的 image，然后加载到内存开始执行，image 执行起来就是所谓的 [container](#容器（Container）)。
### 4. docker pull
这个命令的实现也很简单，那就是用户通过 docker client 发送命令，docker daemon 接收到命令后向 [docker registry](#仓库（Repository）) 发送 image 下载请求，下载后存放在本地，这样我们就可以使用 image 了。
镜像构建完成后，一般会在当前宿主机上，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，[Docker Registry](#仓库（Repository）) 就是这样一个服务，用来保存镜像。它与我们常用的maven reopsitory是一个类似的东西，只是装的东西不同而已。
每个Docker Registry可以包含多个[仓库（Repository）](#仓库（Repository）)，一个仓库可以内可以有同一个软件不同版本的镜像。为了对同一镜像不同版本进行区分，每个镜像都有一个对应的标签（tag）用于标记其版本。
我们可以通过` <仓库名>:<标签> `的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。

